# MicroClaw Firecracker SaaS - Nginx 配置
# 子域名路由: {tenant_id}.microclaw.example.com -> VM 172.16.{N}.2:8080

# 控制平面 upstream
upstream control_plane {
    server 127.0.0.1:8080;
}

# 控制平面 API (api.microclaw.example.com)
server {
    listen 443 ssl http2;
    server_name api.microclaw.example.com;

    ssl_certificate     /etc/letsencrypt/live/microclaw.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/microclaw.example.com/privkey.pem;

    # 安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";

    # 限制访问 (建议通过 VPN 或 IP 白名单)
    # allow 10.0.0.0/8;
    # deny all;

    location / {
        proxy_pass http://control_plane;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

# 租户流量 ({tenant_id}.microclaw.example.com)
# 动态 upstream 通过 Lua 或 map 指令实现
# 这里使用简单的 map 方式，实际生产可用 OpenResty + Lua

# 从子域名提取 tenant_id
map $host $tenant_upstream {
    default "";
    "~^(?<tenant>[^.]+)\.microclaw\.example\.com$" $tenant;
}

# 租户 -> VM IP 映射 (由控制平面动态生成)
# 实际生产环境中，此文件由控制平面自动更新后 reload nginx
include /etc/nginx/conf.d/tenant-upstreams.conf;

server {
    listen 443 ssl http2;
    server_name *.microclaw.example.com;

    ssl_certificate     /etc/letsencrypt/live/microclaw.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/microclaw.example.com/privkey.pem;

    # 安全头
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;

    # 请求体大小限制
    client_max_body_size 10m;

    # 超时配置
    proxy_connect_timeout 5s;
    proxy_read_timeout 300s;
    proxy_send_timeout 60s;

    location / {
        # 动态路由到对应的 VM
        # 需要 tenant-upstreams.conf 中定义的 upstream
        set $backend "";

        # 如果 tenant_upstream 未匹配，返回 404
        if ($tenant_upstream = "") {
            return 404;
        }

        # 代理到 VM
        proxy_pass http://$backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket 支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}

# HTTP -> HTTPS 重定向
server {
    listen 80;
    server_name *.microclaw.example.com api.microclaw.example.com;
    return 301 https://$host$request_uri;
}
